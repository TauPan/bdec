## vim:set syntax=mako:

## Create the C 'type' of each protocol entry
<%!
    from bdec.choice import Choice
    from bdec.field import Field
    from bdec.sequence import Sequence
    from bdec.sequenceof import SequenceOf
%>

<%def name="ctype(entry)">
  %if isinstance(entry, Field):
    %if entry.format == Field.INTEGER:
int
    %elif entry.format == Field.TEXT:
char*
    %elif entry.format == Field.HEX:
Buffer
    %elif entry.format == Field.BINARY:
BitBuffer
    %else:
#error Unhandled field format '${entry}'!
    %endif
  %else:
${entry.name|typename}
  %endif
</%def>

<%def name="c_define(entry)" >
  %if isinstance(entry, Sequence):
typedef struct 
{
  %for child in entry.children:
    ${ctype(child)} ${child.name |variable};
  %endfor
} ${entry.name |typename};
  %elif isinstance(entry, Field):
typedef ${ctype(entry)} ${entry.name |typename};
  %elif isinstance(entry, Choice):
typedef struct
{
    %for child in entry.children:
    ${ctype(child)}* ${child.name |variable};
    %endfor
} ${entry.name |typename};
  %elif isinstance(entry, SequenceOf):
typedef struct
{
    ${ctype(entry.children[0])}* items;
    unsigned int count;
} ${entry.name |typename};
  %else:
#error Unsupported entry ${entry}
  %endif
</%def>

<%!
def _get_local_entries(entry, common, offset):
    """
    Query all non-common entries embedded within another entry.
    
    Also includes the initial entry (regardless of whether it is common or
    not). Returns an iterable.
    """
    for child in entry.children:
       if child not in common:
          for sub_child in _get_local_entries(child, common,offset+2):
              yield sub_child
    yield entry
%>

<%def name="define(entry)" >
    %for e in _get_local_entries(entry, common, 0):
      %if not isinstance(e, Field):
${c_define(e)}
      %endif
    %endfor
</%def>

