## vim:set syntax=mako:
<%namespace file="/expression.tmpl" name="expr" />
<%!
    from bdec.data import Data
    from bdec.field import Field
    from bdec.sequence import Sequence
%>

<%!
def _define_params(entry, get_params):
    result = ""
    for param in get_params(entry):
        if param.direction is param.IN:
            result += ", int %s" % param.name
        else:
            result += ", int* %s" % param.name
    return result

def _params(parent, entry, get_invoked_params, local_variables):
    result = ""
    for param in get_invoked_params(parent, entry):
        if param.direction is param.OUT and param.name in local_variables:
            result += ", &%s" % param.name
        else:
            result += ", %s" % param.name
    return result
%>

<%def name="define_params(entry)">
${_define_params(entry, get_params)}
</%def>

<%def name="params(parent, entry)">
${_params(parent, entry, get_invoked_params, local_vars(parent))}
</%def>

<%def name="decodeField(entry, varname)">
    if (${expr.length(entry.length)} > buffer->num_bits)
    {
        return 0;
    }
  %if entry.format == Field.INTEGER:
    %if entry.encoding == Field.BIG_ENDIAN:
    ${varname} = decode_integer(buffer, ${expr.length(entry.length)});
    %else:
    ${varname} = decode_little_endian_integer(buffer, ${expr.length(entry.length)});
    %endif
    %if is_value_referenced(entry):
    *${entry.name |variable} = ${varname};
    %endif
  %elif entry.format == Field.TEXT:
    int i;
    int ${entry.name + ' buffer length' |variable} = ${expr.length(entry.length)} / 8;
    ${varname} = malloc(${entry.name + ' buffer length' |variable} + 1);
    ${varname}[${entry.name + ' buffer length' |variable}] = 0;
    for (i = 0; i < ${entry.name + ' buffer length' |variable}; ++i)
    {
        ${varname}[i] = decode_integer(buffer, 8);
    }
  %elif entry.format == Field.HEX:
    int i;
    ${varname}.length = ${expr.length(entry.length)} / 8;
    ${varname}.buffer = malloc(${varname}.length);
    for (i = 0; i < ${varname}.length; ++i)
    {
        ${varname}.buffer[i] = decode_integer(buffer, 8);
    }
  %elif entry.format == Field.BINARY:
    // FIXME: We are referencing the source buffer!
    ${varname} = *buffer;
    ${varname}.num_bits = ${expr.length(entry.length)};
    buffer->start_bit += ${varname}.num_bits;
    buffer->buffer += buffer->start_bit / 8;
    buffer->start_bit %= 8;
    buffer->num_bits -= ${varname}.num_bits;
  %else:
    #error Unknown field type ${entry}
  %endif
     %if entry.expected is not None:
       %if entry.format == entry.INTEGER:
    if (${varname} != ${int(entry.expected)})
       %elif entry.format == entry.BINARY:
         %if len(entry.expected) < 32:
    if (get_integer(&${varname}) != ${int(entry.expected)})
         %else:
           <% c_hex_text = ''.join('\\x00%02x' % ord(c) for c in str(entry.expected)) %>
    BitBuffer expected = {(unsigned char*)"${c_hex_text}", 0, ${len(entry.expected)}};
    BitBuffer copy = ${varname};
    int isMatch = 1;
    while (expected.num_bits > 0)
    {
        if (decode_integer(&expected, 1) != decode_integer(&copy, 1))
        {
            isMatch = 0;
            break;
        }
    }
    if (!isMatch)
         %endif
       %else:
#error Field of type ${entry.format} not currently supported for an expected value!
       %endif
    {
        return 0;
    }
     %endif
</%def>
