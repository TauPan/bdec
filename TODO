These page is a list of things it would be nice to have in both the
`protocol specification`_, the implementation_, and in `other
areas`_.


Implementation
==============

File backed data source
-----------------------

Use a file backed data source, so we don't need to load the entire
binary data into memory. For inputs that don't use seeking (eg: stdin),
create a memory backed file source (whenever Data.copy() is called).


Encode shouldn't hold the entire output in memory
-------------------------------------------------

Currently the decode utility waits until all of the data has been
read; instead it should write out data as it becomes available.


Choice should be smart about choosing best guess
------------------------------------------------

Instead of attempting to fully decode one field at a time, the choice
entry should attempt to figure out what entries it couldn't be, then
decode just that one entry.


Generate an xml specification from an in memory protocol
--------------------------------------------------------

Being able to generate an an xml spec from an in memory protocol would
make it easy to convert between different protocol representations.


Allow encoding of a protocol with complex expressions
-----------------------------------------------------

Currently encoding protocols that have complex expressions isn't supported.
This would be a useful feature.


Allow selecting fields from under a choice
------------------------------------------

Some protocols encode fields as being one of several lengths; to use that
field as a length requires us to be able to select fields under a choice
in an expression (only valid if every option of the choice supports that
field).


Protocol specification
======================

Recursive common elements
-------------------------

It would be useful to be able to recursively reference common entries.
A simple example is parsing of a null terminated string; if it is zero,
then no more characters, otherwise read another.

eg:: 

   <choice name="null terminting:">
      <field name="null:" length="8" value="0x0" /> 
      <sequence name="non null:">
         <field name="char" length="8" type="ascii" />
         <choice name="null terminating:" />
      </sequence>
   </choice>

Note that this has very poor recursive characteristics... maybe a better
way for these instances would be a modified sequenceof. (see jpeg 'image 
file directory' for a more complex recursive entry).


Changing 'default' encoding
---------------------------

The tiff header in the jpeg format has a field that specifies the 'encoding'
of all integers that follow (eg: little endian or big endian). This currently
means writing the specification _twice_, once with big endian format and
once for little endian format. Add a mechanism to change the default format for
all 'embedded' fields.

eg::

   <common>
       <sequence name="structure">
           <field name="length:" length="16" type="integer" encoding="default" />
           <field name="data" length="${length:} * 8" type="ascii" />
       </sequence>
   </common>
   <choice name="encoding:">
      <sequence name="intel:">
          <field name="id:" length="8" value="0x0" />
          <default-encoding value="big endian" />
          <sequence name="structure" />
      </sequence>
      <sequence name="motorola:">
          <field name="id:" length="8" value="0x1" />
          <default-encoding value="little endian" />
          <sequence name="structure" />
      </sequence>
   </choice>


Out of order decoding
---------------------

For some protocols (eg: 'image file directory' of jpeg), the encoding of certain
fields is defined at runtime, but such that the data to be decoded isn't aligned
with the format specifier.

eg::

   <common>
       <choice name="data type">
           <field name="integer" length="8" value="0x0" />
           <field name="string" length="8" value="0x0" />
           <field name="float" length="8" value="0x0" />
       </choice>
   </common>
   <sequence name="data">
      <field name="num items:" length="8" type="integer" />
      <sequenceof name="items" length="${num items:}">
         <choice name="data type" />
      </sequenceof>
      <!-- And now the list of items, with the types just specified... -->
      <!-- ???? -->
   </sequence>


Other areas
===========

Compile to other languages
--------------------------

Add a utility to 'compile' a specification to another language, such as C.


ASN1
----

Add a utility to load / convert an `asn1`_ specification to the bdec specification
format (for BER and PER).

.. _asn1: http://en.wikipedia.org/wiki/ASN.1


CSN1
----

Add a utility to load / convert an `CSN.1`_ specification to the bdec specification
format.

.. _csn1: http://en.wikipedia.org/wiki/CSN.1


Add a better format protocol
----------------------------

While xml is easier to programmatically read and write, it isn't very nice for the
user. Another 'user-friendly' format would be nice. Perhaps a reStructuredText
document with custom directives would be good; it would allow good 'in protocol'
documentation which is almost always highly desirable.
